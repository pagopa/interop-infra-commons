global:
  logging:
    level: info
    format: text
  env:
      # Description: Limits the number of Kubernetes API requests per second.
      # Default Value: 50
      # Higher values reduce bottlenecks in syncing large applications but can strain the Kubernetes API server. Monitor server metrics to ensure it can handle the increased load.
    - name: ARGOCD_K8S_CLIENT_QPS
      value: "100"
    
      # Description: Defines the maximum burst of requests sent to the Kubernetes API.
      # Default Value: 100
      # Increasing the burst limit improves sync speeds during spikes but could lead to API server throttling if it exceeds capacity.
    - name: ARGOCD_K8S_CLIENT_BURST
      value: "200"
redis-ha:
  enabled: false
redis:
  metrics:
    enabled: false
    service:
      annotations: {}
      clusterIP: None
      labels: {}
      portName: http-metrics
      servicePort: 9121
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      annotations: {}
      enabled: false
      honorLabels: false
      interval: 30s
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scheme: ""
      selector: {}
      tlsConfig: {}  
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 10m
      memory: 64Mi
applicationSet:
  metrics:
    enabled: true
    service:
      annotations: {}
      clusterIP: ""
      labels: {}
      portName: http-metrics
      servicePort: 8080
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      annotations: {}
      enabled: true
      honorLabels: false
      interval: 30s
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scheme: ""
      scrapeTimeout: ""
      selector: {}
      tlsConfig: {}
  name: applicationset-controller
  replicas: 1
  resources:
    limits:
      cpu: 150m
      memory: 256Mi
    requests:
      cpu: 80m
      memory: 64Mi
  service:
    annotations: {}
    labels: {}
    port: 7000
    portName: http-webhook
    type: ClusterIP
controller:
  metrics:
    enabled: true
  replicas: 1
  resources:
    limits:
      cpu: 2
      memory: 4Gi
    requests:
      cpu: 2
      memory: 4Gi
  revisionHistoryLimit: 5
repoServer:
  autoscaling:
    enabled: false
    maxReplicas: 5
    minReplicas: 1
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
  volumes:
    - name: plugin-home
      emptyDir: {}
    - name: cmp-tmp
      emptyDir: {}
  extraArgs: []
  extraContainers: []
  metrics:
    enabled: false
    service:
      annotations: {}
      clusterIP: ""
      labels: {}
      portName: http-metrics
      servicePort: 8084
      type: ClusterIP
    serviceMonitor:
      additionalLabels: {}
      annotations: {}
      enabled: true
      honorLabels: false
      interval: 30s
      metricRelabelings: []
      namespace: ""
      relabelings: []
      scheme: ""
      scrapeTimeout: ""
      selector: {}
      tlsConfig: {}
  replicas: 1
  resources:
    limits:
      cpu: 1
      memory: 4Gi
    requests:
      cpu: 1
      memory: 4Gi
server:
  replicas: 1
  autoscaling:
    enabled: false
    maxReplicas: 5
    minReplicas: 1
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
  resources:
    limits:
      cpu: 1
      memory: 3Gi
    requests:
      cpu: 1
      memory: 3Gi
configs:
  params:
    # Allows insecure connections to the Argo CD API server.
    server.insecure: "true"
    # https://aws.amazon.com/it/blogs/opensource/argo-cd-application-controller-scalability-testing-on-amazon-eks/
    # status/operations processors:
    # Argo CD utilizes two queues to perform reconciliation (status) and application syncing (operations).
    # The number of processors to service those queues are controlled with the status and operations processor settings.
    # When the application reconciliation or sync is too slow, you need to increase the status and operation queue processors
    # status processors, as the name suggests is responsible to get the app info (Synced, Health, OutOfSync, Degraded, Unknown, Suspended, Missing, Error etc)

    # Description: Sets the number of processors for managing sync operations.
    # Default Value: 10
    # Like status processors, this boosts parallelism at the cost of additional resource usage.
    controller.operation.processors: "50"

    # Description: Sets the number of processors for status reconciliation tasks.
    # Default Value: 20
    # Increasing processors improves parallelism but demands more CPU and memory resources.
    controller.status.processors: "50"

    # Whenever Application Controller shows Context deadline exceeded (this will happend for large manifests), 
    # it was unable to fetch the manifests from repo server within the mentioned controller.repo.server.timeout.secods
    # Default Value: 60s
    controller.repo.server.timeout.seconds: "180"

    # By default there is not limit for parallel manifest generation.
    # Repo server tries to generate all the manifests at a time. Which causes OMM killed issues and manifest generation will to too slow
    # Description: Limits concurrent repository server operations.
    # Default Value: 0 — means infinity
    reposerver.parallelism.limit: "30"

    # Description: Specifies the timeout for repository server operation
    # Default Value: 60
    # Increasing this timeout helps with syncing larger repositories but may delay detecting actual failures.
    server.repo.server.timeout.seconds: "180"

    # Description: Limits concurrent kubectl operations.
    # Default Value: 20
    # Increasing this helps manage larger deployments but could overwhelm cluster resources.
    controller.kubectl.parallelism.limit: "100"

    controller.diff.server.side: "false"
    
  cm:
    timeout.hard.reconciliation: 300s
    timeout.reconciliation: 120s
    timeout.reconciliation.jitter: 60s
    resource.exclusions: |
      - apiGroups:
          - coordination.k8s.io
        kinds:
          - Lease
        clusters:
          - "*"
      - apiGroups:
          - ""
        kinds:
          - Endpoints
          - Event
        clusters:
          - "*"

      -- Custom health-check for ApplicationSet.
      -- DATA READS:
      --   - obj.status.conditions: conditions from the ApplicationSet controller (e.g., ErrorOccurred)
      --   - obj.status.resources: list of generated Applications, with:
      --       res.name            -> child Application name
      --       res.health.status   -> aggregated health of the Application (Healthy/Progressing/Degraded/Missing/...)
      --       res.status          -> sync status of the Application (Synced/OutOfSync/Unknown/...)
      -- EFFECT IN THE UI:
      --   - Sets the "Health" of the ApplicationSet node in Argo CD trees/tiles.
      --   - Shows Degraded/Progressing/Healthy based on child state and controller conditions.

      hs = {}

      -- If status is not yet populated by the controller, treat as progressing.
      -- UI: ApplicationSet shows "Progressing" with an explanatory message.
      if obj.status == nil then
        hs.status = "Progressing"
        hs.message = "Waiting for ApplicationSet controller to populate status"
        return hs
      end

      -- Handle known controller-level errors (e.g., template/generation failed).
      -- If ErrorOccurred=True, degrade immediately.
      -- UI: ApplicationSet shows "Degraded" with the controller error message.
      if obj.status.conditions ~= nil then
        for _, c in ipairs(obj.status.conditions) do
          if c.type == "ErrorOccurred" and c.status == "True" then
            hs.status = "Degraded"
            hs.message = c.message or "ApplicationSet controller reported an error"
            return hs
          end
        end
      end

      -- If no Applications have been generated yet, we’re still progressing.
      -- UI: "Progressing" with explanation.
      local hasResources = obj.status.resources ~= nil and #obj.status.resources > 0
      if not hasResources then
        hs.status = "Progressing"
        hs.message = "No generated Applications yet"
        return hs
      end

      -- Classify generated Applications:
      --  - unhealthy: children with health Degraded (red)
      --  - progressing: children with health Progressing (yellow)
      --  - outofsync: children with health Missing (drift) or sync != Synced
      -- UI: these lists drive the final ApplicationSet health below.
      local unhealthy = {}
      local progressing = {}
      local outofsync = {}

      for _, res in ipairs(obj.status.resources) do
        local h = (res.health and res.health.status) or "Unknown"
        local s = res.status or "Unknown"
        if h == "Degraded" then
          table.insert(unhealthy, res.name) -- child is red
        elseif h == "Missing" then
          table.insert(outofsync, res.name) -- child is out of sync (missing)
        elseif h == "Progressing" then
          table.insert(progressing, res.name) -- child is in progress
        elseif s ~= "Synced" then
          table.insert(outofsync, res.name) -- any other non-synced case
        end
      end

      -- Final health decision for the ApplicationSet based on children.
      -- Priority: Degraded > Progressing (OutOfSync) > Progressing (in progress) > Healthy
      -- UI:
      --    - If any child is Degraded -> ApplicationSet "Degraded" (red).
      --    - Else, if any child is OutOfSync/Missing -> "Progressing" (yellow) with list.
      --    - Else, if any child is Progressing -> "Progressing" (yellow).
      --    - If all are Healthy & Synced -> "Healthy" (green).
      if #unhealthy > 0 then
        hs.status = "Degraded"
        hs.message = "Unhealthy Applications: " .. table.concat(unhealthy, ", ")
        return hs
      elseif #outofsync > 0 then
        hs.status = "Progressing"
        hs.message = "OutOfSync Applications: " .. table.concat(outofsync, ", ")
        return hs
      elseif #progressing > 0 then
        hs.status = "Progressing"
        hs.message = "Applications still progressing: " .. table.concat(progressing, ", ")
        return hs
      else
        hs.status = "Healthy"
        hs.message = "All generated Applications are Healthy and Synced"
        return hs
      end